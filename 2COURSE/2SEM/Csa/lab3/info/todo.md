1. Переписать код на нормальный
2. golden тесты написать, лог. Логгер исправить, см старые версии
3. Обработка флагов ALU
4. Перевести все на latch, сигналы
6. Вместо регистров используется стек
7. Обработка и остановка моделирования при пустом буфере ввода
8. Адресация памяти???
9. Данные программ не должны храниться, как отдельные инструкции (к примеру: строка hello хранится как 5 инструкций
   записи константы в регистр) - вынести в блок data строки? Уточнить у Кости.
10. Мультиплексор на выбор ввода из стека или пользователя, или памяти
11. Для циклов: убрать i из летча в стек. Начало, конец, i хранятся в loop stack. Шаг фиксирован, равен 1. Когда loop
    end
    выполняет сравнение, то он делаем джамп в начало цикла. ИЛИ. Когда идет последовательность 10 1 do, 10 и 1 в стек.
    Когда
    процессор увидел do, то перенес из стека в луп стек и добавил i. 

План: 6, 4, 3, 8, 9, 10, 11, 7, 2, 1

## Вариант - forth | stack | neum | mc -> hw | instr | struct | stream | mem | pstr | prob1 | cache


Переписать IO: Сделать функции signal_ oe(output enable, чтение из памяти), we(write enable, запись в память).

we
Для ввода строки из кода. Помещаем в стек адрес, помещаем в стек код, помещаем символ в память, инкремент и тд.
Для ввода строк из пользовательского ввода (оставить только accept, причем сразу из буфера в модели). В стек адрес, получаем код символа, помещаем в стек код символа, записываем в память, делаем инкремент. Так идем, пока не закончится буфер ввода.
Использовать для записи значений в стек (а не только память).

oe
Для вывода строк из кода или инпута. Передаем адрес в стек, получаем значение из памяти в стек, выводим значение, инкремент. Идем, пока не закончится (либо пока длина не исчерпана, ее тоже в стек).
Использовать для чтения значений из стека. Так же прикрутить чтение для инструкций.

Обновить остальной код (обработка опкодов) для работы со стеком напрямую.