def second_pass(commands):
    code = []
    index = 0
    loop_stack = []
    if_stack = []
    string_storage_address = IOAddresses.STRING_STORAGE
    print(commands)

    i = 0
    while i < len(commands):
        command = commands[i]
        opcode = None
        arguments = []
        print(i)

        if command.isdigit():
            arguments.append(int(command))
            opcode = Opcode.PUSH
        elif " do" in command:
            parts = command.split()
            if len(parts) != 3 or parts[2] != "do":
                raise ValueError("Invalid 'do' loop syntax")
            max_value = int(parts[0]) - 1
            initial_value = int(parts[1])
            step = 1  # Шаг цикла всегда равен 1

            loop_start_index = index
            code.append(
                {
                    "index": index,
                    "opcode": Opcode.LOOP_START.value,
                    "arg": [initial_value, max_value, step],
                }
            )
            loop_stack.append(loop_start_index)
            index += 1
            i += 1
            continue
        elif command == "loop":
            if not loop_stack:
                raise ValueError("Mismatched 'loop' without 'do'")

            loop_start_index = loop_stack.pop()
            code.append(
                {
                    "index": index,
                    "opcode": Opcode.LOOP_END.value,
                    "arg": loop_start_index
                }
            )
            index += 1
            i += 1
            continue
        elif command == "i":
            opcode = Opcode.PUSH
            arguments.append("i")
        elif command == ".":
            opcode = Opcode.PRINT_TOP
        elif command == "mod":
            if i + 1 >= len(commands):
                raise ValueError("Invalid 'mod' syntax")
            arguments.append(int(commands[i + 1]))
            opcode = Opcode.MOD
            i += 1
        elif command == "and":
            opcode = Opcode.AND
        elif command == "or":
            opcode = Opcode.OR
        elif command == "<":
            if i + 1 >= len(commands):
                raise ValueError("Invalid '<' syntax")
            opcode = Opcode.LESS_THAN
            i += 1
        elif command == ">":
            if i + 1 >= len(commands):
                raise ValueError("Invalid '>' syntax")
            opcode = Opcode.GREATER_THAN
            i += 1
        elif command == "==":
            if i + 1 >= len(commands):
                raise ValueError("Invalid '==' syntax")
            opcode = Opcode.EQUALS
            i += 1
        elif command == "if":
            if_stack.append(index)
            code.append(
                {"index": index, "opcode": Opcode.JZ.value, "arg": None})
            index += 1
        elif command == "then":
            if not if_stack:
                raise ValueError("Mismatched 'then' without 'if'")
            if_index = if_stack.pop()
            code[if_index]['arg'] = index
        elif command.startswith('."'):
            string = command[3:-1]
            length = len(string)
            code.append(
                {
                    "index": index,
                    "opcode": Opcode.SAVE_STRING.value,
                    "arg": [string_storage_address, length, string],
                }
            )
            index += 1
            code.append(
                {
                    "index": index,
                    "opcode": Opcode.PSTR.value,
                    "arg": string_storage_address,
                }
            )
            string_storage_address += length + 1
        elif command == "cr":
            opcode = Opcode.CR
        elif command == "+":
            opcode = Opcode.ADD
        elif command == "pad":
            if i + 2 >= len(commands) or not commands[i + 1].isdigit() or commands[i + 2] != "accept":
                raise ValueError("Invalid 'pad' syntax")
            arguments.append(int(commands[i + 1]))
            opcode = Opcode.ACCEPT
            i += 2
        elif command == "type":
            opcode = Opcode.TYPE
        elif command == "dup":
            opcode = Opcode.DUP

        if opcode:
            code.append(
                {
                    "index": index,
                    "opcode": opcode.value,
                    "arg": arguments[0] if arguments else None,
                }
            )
            index += 1
        i += 1

    code.append({"index": index, "opcode": Opcode.HALT.value, "arg": None})
    for i, instr in enumerate(code):
        instr["index"] = i
    return code