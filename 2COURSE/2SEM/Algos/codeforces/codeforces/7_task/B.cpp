// Oзера
// Ограничение по времени на тест: 3 секунды
// Ограничение по памяти на тест: 256 мегабайт
// Ввод: стандартный ввод
// Вывод: стандартный вывод
//
// Дана сетка a размера n×m из неотрицательных целых чисел, где a_i, _j
// представляет глубину воды в i-й строке и j-м столбце.
//
// Озеро — это набор ячеек, таких что:
//  Каждая ячейка в наборе имеет a_i, _j>0
//  Существует путь между любой парой ячеек в озере, двигаясь вверх, вниз, влево
//  или вправо, несколько раз и не наступая на ячейку с ai, j=0.
//
//  Объем озера — это сумма глубин всех ячеек в озере.
//  Найдите наибольший объем озера в сетке.
//
//  Входные данные
//  Первая строка входных данных содержит одно целое число t(1≤t≤104) —
//  количество наборов входных данных в тесте. Первая строка каждого набора
//  содержит два целых числа n,m (1≤n,m≤1000) — размеры сетки. Затем следуют n
//  строк, каждая из которых содержит m целых чисел a_i,_j (0≤a_i,_j≤1000) —
//  глубина воды в каждой ячейке. Гарантируется, что сумма n⋅m по всем наборам
//  не превышает 106.
//
//  Выходные данные
//  Для каждого теста выведите одно целое число — наибольший объем озера в
//  сетке.
//
//  Пример
//  1
//  Входные данные
//  5
//  3 3
//  1 2 0
//  3 4 0
//  0 0 5
//  1 1
//  0
//  3 3
//  0 1 1
//  1 0 1
//  1 1 1
//  5 5
//  1 1 1 1 1
//  1 0 0 0 1
//  1 0 5 0 1
//  1 0 0 0 1
//  1 1 1 1 1
//  5 5
//  1 1 1 1 1
//  1 0 0 0 1
//  1 1 4 0 1
//  1 0 0 0 1
//  1 1 1 1 1
//  Выходные данные
//  10
//  0
//  7
//  16
//  21

#include <algorithm>
#include <climits>
#include <iostream>
#include <map>
#include <queue>
#include <vector>

using namespace std;

int grid[1000][1000];
bool visited_grid[1000][1000];

int n, m;

int calculate_max_volume(int x, int y) {
  if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0 ||
      visited_grid[x][y]) {
    return 0;
  }
  visited_grid[x][y] = true;
  int vol = grid[x][y];

  vol += calculate_max_volume(x + 1, y);
  vol += calculate_max_volume(x - 1, y);
  vol += calculate_max_volume(x, y + 1);
  vol += calculate_max_volume(x, y - 1);

  return vol;
}

int main() {
  int t;
  cin >> t;

  while (t--) {
    cin >> n >> m;

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        cin >> grid[i][j];
        visited_grid[i][j] = false;
      }
    }

    int max_volume = 0;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        max_volume = max(max_volume, calculate_max_volume(i, j));
      }
    }
    cout << max_volume << endl;
  }
  return 0;
}