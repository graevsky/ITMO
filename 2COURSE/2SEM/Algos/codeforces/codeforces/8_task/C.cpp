// Опять пожар
// Ограничение по времени на тест - 2 seconds
// Ограничение по памяти на тест - 64 megabytes
// Ввод input.txt
// Вывод output.txt
//
// После ужасающего лесного пожара в Берляндии была реализована программа
// восстановления леса, по которой были посажены N рядов по M деревьев в каждом,
// причем настолько ровно, что можно ввести систему координат, в которой j-тое
// дерево в i-м ряду будет иметь координаты (i, j). Но случилось ужасное, и едва
// окрепший лес загорелся. И теперь для составления плана эвакуации необходимо
// найти координаты дерева, которое загорится позже всех.
//
// Возгорание произошло в K точках одновременно, т.е. в начальный момент времени
// загорелось K деревьев. Каждую минуту огонь перекидывается со всех горящих
// деревьев на те деревья, которые еще не горят и расстояние от которых до
// ближайшего горящего дерева равно 1.
//
// Найдите дерево, которое загорится позже всех. Если таких деревьев несколько,
// выведите любое.
//
// Входные данные
// В первой строке входного файла заданы два целых числа N, M (1<=N,M<=2000) —
// размеры леса. Деревья были посажены во всех точках вида (x,y) (1≤x≤N,1≤y≤M),
// x и y — целые числа. Во второй строке задано одно целое число K (1≤K≤10) —
// количество деревьев, горящих в начальный момент времени. В третьей строке
// задано K пар целых чисел: x1,y1,x2,y2,...,xk,yk (1≤xi≤N,1≤yi≤M) — координаты
// точек возгорания. Гарантируется, что все точки возгорания различны.
//
// Выходные данные
// Выведите одну строку, содержащую два целых числа x и y, записанные через
// пробел, — координаты дерева, которое загорится последним. Если таких деревьев
// несколько, выведите любое из них.
//
// Примеры
//
// 1
// Входные данные
// 3 3
// 1
// 2 2
// Выходные данные
// 1 1
//
// 2
// Входные данные
// 3 3
// 1
// 1 1
// Выходные данные
// 3 3
//
// 3
// Входные данные
// 3 3
// 2
// 1 1 3 3
// Выходные данные
// 2 2

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <queue>
#include <vector>

using namespace std;

int main() {
  ifstream inp("input.txt");
  ofstream out("output.txt");

  int n, m, k;
  inp >> n >> m >> k;
  // cin >> n >> m >> k;
  vector<vector<int>> trees(n, vector<int>(m, -1));
  queue<pair<int, int>> q;

  for (int i = 0; i < k; i++) {
    int x, y;
    inp >> x >> y;
    // cin >> x >> y;
    x--;
    y--;
    trees[x][y] = 0;
    q.emplace(x, y);
  }

  int BFS_dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

  pair<int, int> last_tree;

  int max_time = 0;

  while (!q.empty()) {
    auto [x, y] = q.front();
    q.pop();

    int time = trees[x][y];

    for (auto &dir : BFS_dirs) {
      int dx = x + dir[0];
      int dy = y + dir[1];

      if (dx >= 0 && dx < n && dy >= 0 && dy < m && trees[dx][dy] == -1) {
        trees[dx][dy] = time + 1;
        q.emplace(dx, dy);

        if (trees[dx][dy] > max_time) {
          max_time = trees[dx][dy];
          last_tree = {dx, dy};
        }
      }
    }
  }

  out << last_tree.first + 1 << " " << last_tree.second + 1;
  // cout << last_tree.first + 1 << " " << last_tree.second + 1;
  return 0;
}