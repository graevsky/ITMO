// Цифровой логарифм

// Определим f(x) для положительного числа x как длину десятичного представления
// x без лидирующих нулей. Мне нравится называть это цифровым логарифмом. Похоже
// на цифровой корень, если вы с таким знакомы.

// Даны два массива a и b, каждый содержит по n целых положительных чисел. За
// одну операцию вы можете сделать следующее:

// 1. выбрать целое число i от 1 до n;
// 2. присвоить либо f(a_i) вместо a_i , либо f(b_i) вместо b_i.

// Два массива называются похожими друг на друга, если можно переупорядочить
// элементы в них обоих так, чтобы они стали равны (т.е. a_i = b_i для всех i от
// 1 до n). Какое наименьшее количество операций надо сделать, чтобы a и b
// стали похожими друг на друга?

// Входные данные
// В первой строке записано одно целое число t (1 <= t <= 10^4) — количество
// наборов входных данных. В первой строке каждого набора входных данных
// записано одно целое число n (1 <= n <= 2*10^5) — количество элементов в
// каждом из массивов. Во второй строке записаны n целых чисел a_1, a_2, ...,
// a_n (1 <= a_i < 10^9). В третьей строке записаны n целых чисел b_1, b_2, ...,
// b_n (1 <= b_j < 10^9). Сумма n по всем наборам входных данных не превосходит
// 2*10^5.

// Выходные данные На каждый набор входных данных выведите наименьшее количество
// операций, которые надо сделать, чтобы a и b стали похожими друг на друга.

#include <bits/stdc++.h>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

int f(int x) {
  int length = 0;
  while (x > 0) {
    length++;
    x /= 10;
  }
  return length;
}

int main() {
  int t;
  cin >> t;

  while (t--) {
    int n;
    cin >> n;

    priority_queue<int> a, b;

    for (int i = 0; i < n; i++) {
      int x;
      cin >> x;
      a.push(x);
    }
    for (int i = 0; i < n; i++) {
      int x;
      cin >> x;
      b.push(x);
    }

    int counter = 0;

    while (!a.empty() and !b.empty()) {
      if (a.top() == b.top()) {
        a.pop();
        b.pop();
      } else {
        priority_queue<int> &new_pq = (a.top() > b.top() ? a : b);
        int top = new_pq.top();
        new_pq.pop();

        int new_value = f(top);
        if (new_value != top) {
          new_pq.push(new_value);
        }
        counter++;
      }
    }

    cout << counter << endl;
  }
  return 0;
}
